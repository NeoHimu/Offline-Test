{"remainingRequest":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/babel-loader/lib/index.js!/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/eslint-loader/index.js??ref--13-0!/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/src/store.js","dependencies":[{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/src/store.js","mtime":1561228069477},{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _Promise from \"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/@babel/runtime-corejs2/core-js/promise\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _JSON$stringify from \"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/@babel/runtime-corejs2/core-js/json/stringify\";\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport ls from './api/localStorageService';\nimport idbs from './api/indexedDBService';\nVue.use(Vuex);\nexport default new Vuex.Store({\n  state: {\n    courses_data: [],\n    questions_paper: [],\n    dataFields: ['courses_data', 'questions_paper']\n  },\n  mutations: {\n    setState: function setState(state, _ref) {\n      var field = _ref.field,\n          data = _ref.data;\n      Vue.set(state, field, data);\n    },\n    loadCourses: function loadCourses(state, newData) {\n      // if local storage is empty or new data arrived\n      if (state.courses_data === [] || _JSON$stringify(state.courses_data[0]) !== _JSON$stringify(newData)) {\n        state.courses_data = []; // this is done to avoid the case if wrong uid and pwd response is stored in the indexeddb storage\n\n        state.courses_data.push(newData);\n      }\n    },\n    loadQuestions: function loadQuestions(state, newData) {\n      // if local storage is empty or new data arrived\n      if (state.questions_paper === [] || _JSON$stringify(state.questions_paper[0]) !== _JSON$stringify(newData)) {\n        state.questions_paper = []; // this is done to avoid the case if wrong uid and pwd response is stored in the indexeddb storage\n\n        state.questions_paper.push(newData);\n      }\n    }\n  },\n  actions: {\n    loadCourses: function loadCourses(_ref2, newData) {\n      var commit = _ref2.commit,\n          dispatch = _ref2.dispatch;\n\n      if (this.state.courses_data === [] || _JSON$stringify(this.state.courses_data[0]) !== _JSON$stringify(newData)) {\n        commit('loadCourses', newData);\n        dispatch('saveData');\n      }\n    },\n    loadQuestions: function loadQuestions(_ref3, newData) {\n      var commit = _ref3.commit,\n          dispatch = _ref3.dispatch;\n\n      if (this.state.questions_paper === [] || _JSON$stringify(this.state.questions_paper[0]) !== _JSON$stringify(newData)) {\n        commit('loadQuestions', newData);\n        dispatch('saveData');\n      }\n    },\n    checkStorage: function checkStorage(_ref4) {\n      var state = _ref4.state,\n          commit = _ref4.commit;\n      state.dataFields.forEach(\n      /*#__PURE__*/\n      function () {\n        var _ref5 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee(field) {\n          var data;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return idbs.checkStorage(field);\n\n                case 3:\n                  data = _context.sent;\n                  // IndexedDB did not find the data, try localStorage\n                  if (data === undefined) data = ls.checkStorage(field); // LocalStorage did not find the data, reset it\n\n                  if (data === null) data = [];\n                  commit('setState', {\n                    field: field,\n                    data: data\n                  });\n                  _context.next = 12;\n                  break;\n\n                case 9:\n                  _context.prev = 9;\n                  _context.t0 = _context[\"catch\"](0);\n                  // The value in storage was invalid or corrupt so just set it to blank\n                  commit('setState', {\n                    field: field,\n                    data: []\n                  });\n\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 9]]);\n        }));\n\n        return function (_x) {\n          return _ref5.apply(this, arguments);\n        };\n      }());\n    },\n    saveData: function () {\n      var _saveData = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(_ref6) {\n        var state;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                state = _ref6.state;\n                _context2.prev = 1;\n                _context2.next = 4;\n                return _Promise.all(state.dataFields.map(function (field) {\n                  return idbs.saveToStorage(field, state[field]);\n                }));\n\n              case 4:\n                _context2.next = 9;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](1);\n                state.dataFields.forEach(function (field) {\n                  return ls.saveToStorage(field, state[field]);\n                });\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 6]]);\n      }));\n\n      function saveData(_x2) {\n        return _saveData.apply(this, arguments);\n      }\n\n      return saveData;\n    }()\n  }\n});",{"version":3,"sources":["/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/src/store.js"],"names":["Vue","Vuex","ls","idbs","use","Store","state","courses_data","questions_paper","dataFields","mutations","setState","field","data","set","loadCourses","newData","push","loadQuestions","actions","commit","dispatch","checkStorage","forEach","undefined","saveData","all","map","saveToStorage"],"mappings":"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","sourcesContent":["import Vue from 'vue'\nimport Vuex from 'vuex'\n\nimport ls from './api/localStorageService'\nimport idbs from './api/indexedDBService'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  state: {\n    courses_data: [],\n    questions_paper: [],\n    dataFields: ['courses_data', 'questions_paper']\n  },\n  mutations: {\n    setState (state, { field, data }) {\n      Vue.set(state, field, data)\n    },\n    loadCourses (state, newData) {\n      // if local storage is empty or new data arrived\n      if(state.courses_data===[] || JSON.stringify(state.courses_data[0]) !== JSON.stringify(newData) )\n      {\n        state.courses_data = [] // this is done to avoid the case if wrong uid and pwd response is stored in the indexeddb storage\n        state.courses_data.push(newData)\n      }\n    },\n    loadQuestions (state, newData) {\n      // if local storage is empty or new data arrived\n      if(state.questions_paper===[] || JSON.stringify(state.questions_paper[0]) !== JSON.stringify(newData) )\n      {\n        state.questions_paper = [] // this is done to avoid the case if wrong uid and pwd response is stored in the indexeddb storage\n        state.questions_paper.push(newData)\n      }\n    },\n  },\n  actions: {\n    loadCourses ({ commit, dispatch }, newData) {\n      if(this.state.courses_data===[] || JSON.stringify(this.state.courses_data[0]) !== JSON.stringify(newData) )\n      {\n        commit('loadCourses', newData)\n        dispatch('saveData')\n      }\n    },\n\n    loadQuestions ({ commit, dispatch }, newData) {\n      if(this.state.questions_paper===[] || JSON.stringify(this.state.questions_paper[0]) !== JSON.stringify(newData) )\n      {\n        commit('loadQuestions', newData)\n        dispatch('saveData')\n      }\n    },\n    \n    checkStorage ({ state, commit }) {\n      state.dataFields.forEach(async field => {\n        try {\n          let data = await idbs.checkStorage(field)\n\n          // IndexedDB did not find the data, try localStorage\n          if (data === undefined) data = ls.checkStorage(field)\n\n          // LocalStorage did not find the data, reset it\n          if (data === null) data = []\n\n          commit('setState', { field, data })\n        } catch (e) {\n          // The value in storage was invalid or corrupt so just set it to blank\n          commit('setState', { field, data: [] })\n        }\n      })\n    },\n    async saveData ({ state }) {\n      try {\n        await Promise.all(state.dataFields.map(field => idbs.saveToStorage(field, state[field])))\n      } catch (e) {\n        state.dataFields.forEach(field => ls.saveToStorage(field, state[field]))\n      }\n    }\n  }\n})\n"]}]}