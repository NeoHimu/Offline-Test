{"remainingRequest":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/babel-loader/lib/index.js!/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/eslint-loader/index.js??ref--13-0!/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/src/store.js","dependencies":[{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/src/store.js","mtime":1556867053745},{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _Promise from \"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/@babel/runtime-corejs2/core-js/promise\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _JSON$stringify from \"/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/node_modules/@babel/runtime-corejs2/core-js/json/stringify\";\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport ls from './api/localStorageService';\nimport idbs from './api/indexedDBService';\nVue.use(Vuex);\nexport default new Vuex.Store({\n  state: {\n    todos: [],\n    completed: [],\n    dataFields: ['todos', 'completed']\n  },\n  mutations: {\n    setState: function setState(state, _ref) {\n      var field = _ref.field,\n          data = _ref.data;\n      Vue.set(state, field, data);\n    },\n    addTodo: function addTodo(state, newTodo) {\n      // if local storage is empty or new data arrived\n      if (state.todos === [] || _JSON$stringify(state.todos[0]) !== _JSON$stringify(newTodo)) {\n        state.todos = []; // this is done to avoid the case if wrong uid and pwd response is stored in the indexeddb storage\n\n        state.todos.push(newTodo);\n      }\n    }\n  },\n  actions: {\n    addTodo: function addTodo(_ref2, newTodo) {\n      var commit = _ref2.commit,\n          dispatch = _ref2.dispatch;\n\n      if (this.state.todos === [] || _JSON$stringify(this.state.todos[0]) !== _JSON$stringify(newTodo)) {\n        commit('addTodo', newTodo);\n        dispatch('saveTodos');\n      }\n    },\n\n    /*\n    deleteTodo ({ commit, dispatch }, todoInfo) {\n      commit('deleteTodo', todoInfo)\n      dispatch('saveTodos')\n    },\n    completeTodo ({ commit, dispatch }, todoIndex) {\n      commit('completeTodo', todoIndex)\n      dispatch('saveTodos')\n    },*/\n    checkStorage: function checkStorage(_ref3) {\n      var state = _ref3.state,\n          commit = _ref3.commit;\n      state.dataFields.forEach(\n      /*#__PURE__*/\n      function () {\n        var _ref4 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee(field) {\n          var data;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return idbs.checkStorage(field);\n\n                case 3:\n                  data = _context.sent;\n                  // IndexedDB did not find the data, try localStorage\n                  if (data === undefined) data = ls.checkStorage(field); // LocalStorage did not find the data, reset it\n\n                  if (data === null) data = [];\n                  commit('setState', {\n                    field: field,\n                    data: data\n                  });\n                  _context.next = 12;\n                  break;\n\n                case 9:\n                  _context.prev = 9;\n                  _context.t0 = _context[\"catch\"](0);\n                  // The value in storage was invalid or corrupt so just set it to blank\n                  commit('setState', {\n                    field: field,\n                    data: []\n                  });\n\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 9]]);\n        }));\n\n        return function (_x) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n    },\n    saveTodos: function () {\n      var _saveTodos = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(_ref5) {\n        var state;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                state = _ref5.state;\n                _context2.prev = 1;\n                _context2.next = 4;\n                return _Promise.all(state.dataFields.map(function (field) {\n                  return idbs.saveToStorage(field, state[field]);\n                }));\n\n              case 4:\n                _context2.next = 9;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](1);\n                state.dataFields.forEach(function (field) {\n                  return ls.saveToStorage(field, state[field]);\n                });\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 6]]);\n      }));\n\n      function saveTodos(_x2) {\n        return _saveTodos.apply(this, arguments);\n      }\n\n      return saveTodos;\n    }()\n  }\n});",{"version":3,"sources":["/home/himanshu/Desktop/RA_Work/FOSSEE/prabhu_sir/vue/OfflineTest/src/store.js"],"names":["Vue","Vuex","ls","idbs","use","Store","state","todos","completed","dataFields","mutations","setState","field","data","set","addTodo","newTodo","push","actions","commit","dispatch","checkStorage","forEach","undefined","saveTodos","all","map","saveToStorage"],"mappings":";;;;;;AAAA,OAAOA,GAAP,MAAgB,KAAhB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AAEA,OAAOC,EAAP,MAAe,2BAAf;AACA,OAAOC,IAAP,MAAiB,wBAAjB;AAEAH,GAAG,CAACI,GAAJ,CAAQH,IAAR;AAEA,eAAe,IAAIA,IAAI,CAACI,KAAT,CAAe;AAC5BC,EAAAA,KAAK,EAAE;AACLC,IAAAA,KAAK,EAAE,EADF;AAELC,IAAAA,SAAS,EAAE,EAFN;AAGLC,IAAAA,UAAU,EAAE,CAAC,OAAD,EAAU,WAAV;AAHP,GADqB;AAM5BC,EAAAA,SAAS,EAAE;AACTC,IAAAA,QADS,oBACCL,KADD,QACyB;AAAA,UAAfM,KAAe,QAAfA,KAAe;AAAA,UAARC,IAAQ,QAARA,IAAQ;AAChCb,MAAAA,GAAG,CAACc,GAAJ,CAAQR,KAAR,EAAeM,KAAf,EAAsBC,IAAtB;AACD,KAHQ;AAITE,IAAAA,OAJS,mBAIAT,KAJA,EAIOU,OAJP,EAIgB;AACvB;AACA,UAAGV,KAAK,CAACC,KAAN,KAAc,EAAd,IAAoB,gBAAeD,KAAK,CAACC,KAAN,CAAY,CAAZ,CAAf,MAAmC,gBAAeS,OAAf,CAA1D,EACA;AACEV,QAAAA,KAAK,CAACC,KAAN,GAAc,EAAd,CADF,CACmB;;AACjBD,QAAAA,KAAK,CAACC,KAAN,CAAYU,IAAZ,CAAiBD,OAAjB;AACD;AACF;AAXQ,GANiB;AA+B5BE,EAAAA,OAAO,EAAE;AACPH,IAAAA,OADO,0BACwBC,OADxB,EACiC;AAAA,UAA7BG,MAA6B,SAA7BA,MAA6B;AAAA,UAArBC,QAAqB,SAArBA,QAAqB;;AACtC,UAAG,KAAKd,KAAL,CAAWC,KAAX,KAAmB,EAAnB,IAAyB,gBAAe,KAAKD,KAAL,CAAWC,KAAX,CAAiB,CAAjB,CAAf,MAAwC,gBAAeS,OAAf,CAApE,EACA;AACEG,QAAAA,MAAM,CAAC,SAAD,EAAYH,OAAZ,CAAN;AACAI,QAAAA,QAAQ,CAAC,WAAD,CAAR;AACD;AACF,KAPM;;AAQP;;;;;;;;;AASAC,IAAAA,YAjBO,+BAiB0B;AAAA,UAAjBf,KAAiB,SAAjBA,KAAiB;AAAA,UAAVa,MAAU,SAAVA,MAAU;AAC/Bb,MAAAA,KAAK,CAACG,UAAN,CAAiBa,OAAjB;AAAA;AAAA;AAAA;AAAA;AAAA,gCAAyB,iBAAMV,KAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAEJT,IAAI,CAACkB,YAAL,CAAkBT,KAAlB,CAFI;;AAAA;AAEjBC,kBAAAA,IAFiB;AAIrB;AACA,sBAAIA,IAAI,KAAKU,SAAb,EAAwBV,IAAI,GAAGX,EAAE,CAACmB,YAAH,CAAgBT,KAAhB,CAAP,CALH,CAOrB;;AACA,sBAAIC,IAAI,KAAK,IAAb,EAAmBA,IAAI,GAAG,EAAP;AAEnBM,kBAAAA,MAAM,CAAC,UAAD,EAAa;AAAEP,oBAAAA,KAAK,EAALA,KAAF;AAASC,oBAAAA,IAAI,EAAJA;AAAT,mBAAb,CAAN;AAVqB;AAAA;;AAAA;AAAA;AAAA;AAYrB;AACAM,kBAAAA,MAAM,CAAC,UAAD,EAAa;AAAEP,oBAAAA,KAAK,EAALA,KAAF;AAASC,oBAAAA,IAAI,EAAE;AAAf,mBAAb,CAAN;;AAbqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAzB;;AAAA;AAAA;AAAA;AAAA;AAgBD,KAlCM;AAmCDW,IAAAA,SAnCC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCYlB,gBAAAA,KAnCZ,SAmCYA,KAnCZ;AAAA;AAAA;AAAA,uBAqCG,SAAQmB,GAAR,CAAYnB,KAAK,CAACG,UAAN,CAAiBiB,GAAjB,CAAqB,UAAAd,KAAK;AAAA,yBAAIT,IAAI,CAACwB,aAAL,CAAmBf,KAAnB,EAA0BN,KAAK,CAACM,KAAD,CAA/B,CAAJ;AAAA,iBAA1B,CAAZ,CArCH;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAuCHN,gBAAAA,KAAK,CAACG,UAAN,CAAiBa,OAAjB,CAAyB,UAAAV,KAAK;AAAA,yBAAIV,EAAE,CAACyB,aAAH,CAAiBf,KAAjB,EAAwBN,KAAK,CAACM,KAAD,CAA7B,CAAJ;AAAA,iBAA9B;;AAvCG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA/BmB,CAAf,CAAf","sourcesContent":["import Vue from 'vue'\nimport Vuex from 'vuex'\n\nimport ls from './api/localStorageService'\nimport idbs from './api/indexedDBService'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  state: {\n    todos: [],\n    completed: [],\n    dataFields: ['todos', 'completed']\n  },\n  mutations: {\n    setState (state, { field, data }) {\n      Vue.set(state, field, data)\n    },\n    addTodo (state, newTodo) {\n      // if local storage is empty or new data arrived\n      if(state.todos===[] || JSON.stringify(state.todos[0]) !== JSON.stringify(newTodo) )\n      {\n        state.todos = [] // this is done to avoid the case if wrong uid and pwd response is stored in the indexeddb storage\n        state.todos.push(newTodo)\n      }\n    },\n    /*\n    deleteTodo (state, { todoIndex, isCompleted }) {\n      if (isCompleted) {\n        state.completed.splice(todoIndex, 1)\n      } else {\n        state.todos.splice(todoIndex, 1)\n      }\n    },\n    completeTodo (state, todoIndex) {\n      state.completed.push(state.todos.splice(todoIndex, 1)[0])\n    }\n    */\n  },\n  actions: {\n    addTodo ({ commit, dispatch }, newTodo) {\n      if(this.state.todos===[] || JSON.stringify(this.state.todos[0]) !== JSON.stringify(newTodo) )\n      {\n        commit('addTodo', newTodo)\n        dispatch('saveTodos')\n      }\n    },\n    /*\n    deleteTodo ({ commit, dispatch }, todoInfo) {\n      commit('deleteTodo', todoInfo)\n      dispatch('saveTodos')\n    },\n    completeTodo ({ commit, dispatch }, todoIndex) {\n      commit('completeTodo', todoIndex)\n      dispatch('saveTodos')\n    },*/\n    checkStorage ({ state, commit }) {\n      state.dataFields.forEach(async field => {\n        try {\n          let data = await idbs.checkStorage(field)\n\n          // IndexedDB did not find the data, try localStorage\n          if (data === undefined) data = ls.checkStorage(field)\n\n          // LocalStorage did not find the data, reset it\n          if (data === null) data = []\n\n          commit('setState', { field, data })\n        } catch (e) {\n          // The value in storage was invalid or corrupt so just set it to blank\n          commit('setState', { field, data: [] })\n        }\n      })\n    },\n    async saveTodos ({ state }) {\n      try {\n        await Promise.all(state.dataFields.map(field => idbs.saveToStorage(field, state[field])))\n      } catch (e) {\n        state.dataFields.forEach(field => ls.saveToStorage(field, state[field]))\n      }\n    }\n  }\n})\n"]}]}